;; Problem 61
;; <p>Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and are generated by the following formulae:</p>
;; <table><tr><td>Triangle</td>
;; <td> </td>
;; <td>$P_{3,n}=n(n+1)/2$</td>
;; <td> </td>
;; <td>$1, 3, 6, 10, 15, \dots$</td>
;; </tr><tr><td>Square</td>
;; <td> </td>
;; <td>$P_{4,n}=n^2$</td>
;; <td> </td>
;; <td>$1, 4, 9, 16, 25, \dots$</td>
;; </tr><tr><td>Pentagonal</td>
;; <td> </td>
;; <td>$P_{5,n}=n(3n-1)/2$</td>
;; <td> </td>
;; <td>$1, 5, 12, 22, 35, \dots$</td>
;; </tr><tr><td>Hexagonal</td>
;; <td> </td>
;; <td>$P_{6,n}=n(2n-1)$</td>
;; <td> </td>
;; <td>$1, 6, 15, 28, 45, \dots$</td>
;; </tr><tr><td>Heptagonal</td>
;; <td> </td>
;; <td>$P_{7,n}=n(5n-3)/2$</td>
;; <td> </td>
;; <td>$1, 7, 18, 34, 55, \dots$</td>
;; </tr><tr><td>Octagonal</td>
;; <td> </td>
;; <td>$P_{8,n}=n(3n-2)$</td>
;; <td> </td>
;; <td>$1, 8, 21, 40, 65, \dots$</td>
;; </tr></table><p>The ordered set of three $4$-digit numbers: $8128$, $2882$, $8281$, has three interesting properties.</p>
;; <ol><li>The set is cyclic, in that the last two digits of each number is the first two digits of the next number (including the last number with the first).</li>
;; <li>Each polygonal type: triangle ($P_{3,127}=8128$), square ($P_{4,91}=8281$), and pentagonal ($P_{5,44}=2882$), is represented by a different number in the set.</li>
;; <li>This is the only set of $4$-digit numbers with this property.</li>
;; </ol><p>Find the sum of the only ordered set of six cyclic $4$-digit numbers for which each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.</p>

(ns project-euler-clj.problem-061
  (:require [project-euler-clj.common :as common])
  (:require [clojure.math.combinatorics :as combo]))

(defn gen-cadidate-seq
  [lazy-poly-seq]
  (take-while (fn [[_ m]] (< m 10000))
              (filter (fn [[_ n]] (<= 1000 n))
                      (map-indexed vector
                                   lazy-poly-seq))))

(def seqs [[:tri common/tri-seq]
           [:sqr common/square-seq]
           [:pen common/penta-seq]
           [:hex common/hexa-seq]
           [:hep common/hepta-seq]
           [:oct common/octa-seq]])

(defn serialise-seq
  [k s]
  (map (fn [[n term]] (let [n-sq (common/num-to-digit-seq term)]
                        [k n n-sq]))
       (gen-cadidate-seq (s))))

(def dict (reduce (fn [m [k v]] (update m k #(conj % v)))
                  {}
                  (apply concat (map (fn [[k s]] (map (fn [entry] [(take 2 (last entry))
                                                                   entry])
                                                      (serialise-seq k s)))
                                     seqs))))

(defn- maybe-add
  [sq old-names term]
  (let [terms-sq-name (first term)]
    (if (not (contains? old-names
                        terms-sq-name))
      (conj sq term))))

(def candidates (loop [chains (map vector (serialise-seq :tri common/tri-seq))]
                  (if-let [loop-candidates (seq (filter #(= 6 (count %)) chains))]
                    loop-candidates
                    (recur (apply concat
                                  (map (fn [sq] (let [k (take-last 2 (last (last sq)))
                                                      old-names (set (map first sq))
                                                      new-terms (dict k)]
                                                  (map (fn [t] (maybe-add sq old-names t))
                                                       new-terms)))
                                       chains))))))

(defn solve
  []
  (reduce +
          (map (fn [x] (common/digit-seq-to-num (last x)))
               (first (filter (fn [sq] (= (take 2 (last (first sq)))
                                          (take-last 2 (last (last sq)))))
                              candidates)))))
